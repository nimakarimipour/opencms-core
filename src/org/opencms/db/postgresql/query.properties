# PostGRE SQL specific because of the row limitation
C_POSTGRE_PROJECTS_READLAST_HISTORY=\
SELECT \
	PUBLISH_TAG,\
	PROJECT_ID,\
	PROJECT_NAME,\
	PROJECT_PUBLISHDATE,\
	PROJECT_PUBLISHED_BY,\
	PROJECT_DESCRIPTION,\
	USER_ID,\
	GROUP_ID,\
	MANAGERGROUP_ID,\
	DATE_CREATED,\
	PROJECT_TYPE,\
	PROJECT_OU \
FROM \
	CMS_HISTORY_PROJECTS \
ORDER BY \
	PUBLISH_TAG DESC \
LIMIT ?

# PostGRE SQL specific because of missing concat function: use concat operator ||
C_READ_RESOURCE_OUS=\
SELECT DISTINCT \
	${C_RELATIONS_SELECT_ATTRIBS} \
FROM \
	CMS_${PROJECT}_RESOURCE_RELATIONS \
WHERE \
    CMS_${PROJECT}_RESOURCE_RELATIONS.RELATION_TYPE = ? \
    AND ? LIKE (CMS_${PROJECT}_RESOURCE_RELATIONS.RELATION_TARGET_PATH || '%')
    
# NOT EXISTS (SELECT ID FROM FOO WHERE ID = XYZ ) is much faster than XYZ NOT IN (SELECT ID FROM FOO) in some Postgresql versions when FOO is big   
C_RELATIONS_REPAIR_BROKEN=\
UPDATE \
    CMS_${PROJECT}_RESOURCE_RELATIONS \
SET \
    RELATION_TARGET_ID = ? \
WHERE \
    CMS_${PROJECT}_RESOURCE_RELATIONS.RELATION_TARGET_PATH = ? \
    AND NOT EXISTS (SELECT CMS_${PROJECT}_STRUCTURE.STRUCTURE_ID FROM CMS_${PROJECT}_STRUCTURE WHERE CMS_${PROJECT}_STRUCTURE.STRUCTURE_ID = CMS_${PROJECT}_RESOURCE_RELATIONS.RELATION_TARGET_ID)


# NOT EXISTS (SELECT ID FROM FOO WHERE ID = XYZ ) is much faster than XYZ NOT IN (SELECT ID FROM FOO) in some Postgresql versions when FOO is big 
C_RELATIONS_UPDATE_BROKEN=\
UPDATE \
    CMS_${PROJECT}_RESOURCE_RELATIONS \
SET \
    RELATION_TARGET_ID = '00000000-0000-0000-0000-000000000000' \
WHERE \
    CMS_${PROJECT}_RESOURCE_RELATIONS.RELATION_TARGET_PATH = ? \
    AND NOT EXISTS (SELECT CMS_${PROJECT}_STRUCTURE.STRUCTURE_ID FROM CMS_${PROJECT}_STRUCTURE WHERE CMS_${PROJECT}_STRUCTURE.STRUCTURE_ID = CMS_${PROJECT}_RESOURCE_RELATIONS.RELATION_TARGET_ID)


